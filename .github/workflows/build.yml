name: Docker Gnucash CI/CD

on:
  push:
    branches:
      - 'main'
    tags:
      - 'v*'
  pull_request:
    branches:
      - 'main'

env:
  BASEIMAGE_VERSION: ubuntu-24.04-v4
  GNUCASH_VERSION: 5.13
  PLATFORMS: linux/amd64,linux/arm64
  DOCKER_IMAGE_NAME: ${{ vars.DOCKERHUB_USERNAME }}/gnucash
  CACHE_IMAGE_NAME: ghcr.io/${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    services:
      registry:
        image: registry:2
        ports:
          - 5000:5000
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup BATS
        uses: mig4/setup-bats@v1
        with:
          bats-version: 1.13.0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare cache tags
        id: cache
        run: |
          # The cache image name must be lowercase.
          CACHE_IMAGE_NAME="${{ env.CACHE_IMAGE_NAME }}"
          CACHE_IMAGE_NAME="${CACHE_IMAGE_NAME,,}"
          echo "cache-image-name=${CACHE_IMAGE_NAME}" >> $GITHUB_OUTPUT

          # For PRs, we want to read from the main branch cache and the PR's own cache,
          # but only write to the PR's cache.
          if [[ $GITHUB_REF == refs/pull/* ]]; then
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:cache-main,ref=${CACHE_IMAGE_NAME}:cache-${{ github.head_ref }}"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:cache-${{ github.head_ref }},mode=max"
          # For pushes to the main branch that are the result of a PR merge, we
          # want to read from the main branch cache and the PR's cache, but
          # only write to the main branch cache.
          elif [[ $GITHUB_REF == 'refs/heads/main' && github.event.pull_request.merged == 'true' ]]; then
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:cache-main,ref=${CACHE_IMAGE_NAME}:cache-${{ github.event.pull_request.head.ref }}"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:cache-main,mode=max"
          # For all other cases (e.g., direct pushes to main, tag builds), we
          # read from and write to the main branch cache.
          else
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:cache-main"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:cache-main,mode=max"
          fi

          echo "cache-from=${CACHE_FROM}" >> $GITHUB_OUTPUT
          echo "cache-to=${CACHE_TO}" >> $GITHUB_OUTPUT

      - name: Build and push to local registry
        uses: docker/build-push-action@v5
        with:
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci
          build-args: |
            BASEIMAGE_VERSION=${{ env.BASEIMAGE_VERSION }}
            GNUCASH_VERSION=${{ env.GNUCASH_VERSION }}
          cache-from: ${{ steps.cache.outputs.cache-from }}
          cache-to: ${{ steps.cache.outputs.cache-to }}

      - name: Inspect
        id: inspect
        run: |
          # Get the metadata of all platform images from the multi-platform manifest of the above build.
          docker buildx imagetools inspect localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci
          echo "raw=$(docker buildx imagetools inspect --raw localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci | tr -d '\n')" >> $GITHUB_OUTPUT

      - name: Test image
        run: |
          # Run the test suite on all architectures.
          # Get digest and architecture of each manifest in multi-platform image.
          digests=(${{ join(fromJSON(steps.inspect.outputs.raw).manifests.*.digest, ' ') }})
          architectures=(${{ join(fromJSON(steps.inspect.outputs.raw).manifests.*.platform.architecture, ' ') }})
          if [[ "${#digests[@]}" -ne "${#architectures[@]}" ]]; then
            echo "::error::Digest and arch array lengths do no match: [${architectures[@]}] [${digests[@]}]"
            exit 1
          fi
          for ((i=0; i<${#digests[@]}; i++)); do
            digest="${digests[i]}"
            arch="${architectures[i]}"
            echo "Digest: ${digest}"
            echo "Architecture: ${arch}"
            # The multi-platform docker image contains a bunch of manifests, but
            # only the ones that have an valid architecture are manifests of
            # platform sub-images we can actually run.
            if [[ "${arch}" == 'unknown' ]]; then
              echo '... skipping metadata image'
              continue
            fi
            # Run the test suite on one architecture.
            export DOCKER_IMAGE=localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci@${digest}
            echo "Running tests on image ${DOCKER_IMAGE}..."
            docker pull ${DOCKER_IMAGE}
            docker run --rm ${DOCKER_IMAGE} sh -c 'echo Testing image on $(uname -m)...'
            bats -j $(nproc) tests
          done

      - name: Login to Docker Hub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Prepare Github Metadata
        id: meta
        if: github.event_name != 'pull_request'
        run: |
          # Determine the Docker container tags.
          TAGS=""

          if [[ $GITHUB_REF == refs/tags/* ]]; then
            # Git tags are used 'as is' as docker image tags.
            VERSION=${GITHUB_REF#refs/tags/}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"

            if [[ $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
               # Apply semantic version (semver) expansion, i.e., latest X.Y.Z also becomes X.Y and X
               V=${VERSION:1}
               MAJOR_MINOR=${V%.*}
               MAJOR=${MAJOR_MINOR%.*}
               TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:v${MAJOR_MINOR}"
               TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:v${MAJOR}"
            fi

          elif [[ $GITHUB_REF == 'refs/heads/main' ]]; then
            # Git main branch commits are tagged with docker's default 'latest' tag.
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:latest"
            TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:baseimage-gui-${{ env.BASEIMAGE_VERSION }}-gnucash-${{ env.GNUCASH_VERSION }}"

          elif [[ $GITHUB_REF == refs/heads/* ]]; then
            # Other git branches are tagged with the branch name.
            VERSION=${GITHUB_REF#refs/heads/}
            # Basic sanitization (replace / with -)
            VERSION=${VERSION//\//-}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"

          elif [[ $GITHUB_REF == refs/pull/* ]]; then
            # Pull requests are tagged with pr-<PR#>.
            VERSION=pr-${{ github.event.number }}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"
          fi

          echo "tags=${TAGS}" >> $GITHUB_OUTPUT

      - name: Build and push to Dockerhub
        if: github.event_name != 'pull_request'
        uses: docker/build-push-action@v5
        with:
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            BASEIMAGE_VERSION=${{ env.BASEIMAGE_VERSION }}
            GNUCASH_VERSION=${{ env.GNUCASH_VERSION }}
          cache-from: ${{ steps.cache.outputs.cache-from }}
          cache-to: ${{ steps.cache.outputs.cache-to }}

      - name: Update Docker Hub description
        if: github.event_name != 'pull_request' && github.ref == 'refs/heads/main'
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          repository: ${{ env.DOCKER_IMAGE_NAME }}
          readme-filepath: DOCKERHUB.md
