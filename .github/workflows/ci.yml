name: Docker Gnucash CI/CD

on:
  push:
    branches:
      - 'main'
    tags:
      - 'v*'
  pull_request:
    branches:
      - 'main'

concurrency:
  # Cancel unfinished CI/CD runs if a new run starts on the same branch.
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

env:
  BASEIMAGE_VERSION: ubuntu-24.04-v4.10.6
  GNUCASH_VERSION: 5.13
  PLATFORMS: linux/amd64,linux/arm64
  DOCKER_IMAGE_NAME: ${{ vars.DOCKERHUB_USERNAME }}/gnucash

jobs:
  run-pre-commits:
    name: Run pre-commit checks
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required for the 'actions/checkout' step
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: 3.14

      - name: Run pre-commit checks
        uses: pre-commit/action@v3.0.1

  build:
    needs: run-pre-commits
    runs-on: ubuntu-latest
    permissions:
      contents: read       # Required for the 'actions/checkout' step
      pull-requests: read  # Required for the 'gh api' call
      packages: write      # Allows pushing/writing to GHCR
    services:
      registry:
        # Ephemeral docker registry for storing images between build and test.
        image: registry:2
        ports:
          - 5000:5000
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Set up BATS
        uses: mig4/setup-bats@v1
        with:
          bats-version: 1.13.0

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          # Persistent docker registry for caching image layers across CI runs.
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare cache tags
        id: cache
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          HEAD_REF: ${{ github.head_ref }}
        run: |
          # The cache image name must be lowercase.
          CACHE_IMAGE_NAME="ghcr.io/${{ github.repository }}/build-cache"
          CACHE_IMAGE_NAME="${CACHE_IMAGE_NAME,,}"

          sanitize() {
            echo "${1//[^a-zA-Z0-9._-]/_}"
          }

          if [[ $GITHUB_REF == refs/pull/* ]]; then
            # For PRs, we want to read from the main branch cache and the PR's
            # own cache, but only write to the PR's cache.
            CLEAN_REF=$(sanitize "$HEAD_REF")
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:${CLEAN_REF}
            type=registry,ref=${CACHE_IMAGE_NAME}:main"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:${CLEAN_REF}"
            CACHE_TO="${CACHE_TO},mode=max"

          elif [[ $GITHUB_REF == 'refs/heads/main' ]]; then
            # For pushes to the main branch, we read from and write to the main
            # branch cache.
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:main"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:main,mode=max"

            # Try to identify if this push is the result of a PR merge and reuse
            # that PR's cache.
            # Using the GitHub CLI to find the PR associated with the commit.
            PR_BRANCH=$(gh api \
              "repos/${{ github.repository }}/commits/${{ github.sha }}/pulls" \
              --jq '.[0].head.ref')
            if [ -n "$PR_BRANCH" ] && [ "$PR_BRANCH" != "null" ]; then
              echo "Found PR source branch: $PR_BRANCH"
              CLEAN_REF=$(sanitize "$PR_BRANCH")
              CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:${CLEAN_REF}
              ${CACHE_FROM}"
            fi

          elif [[ $GITHUB_REF == refs/heads/* ]]; then
            # For other branches, read from main and branch cache, write to
            # branch cache.
            REF_NAME=${GITHUB_REF#refs/heads/}
            CLEAN_REF=$(sanitize "$REF_NAME")
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:${CLEAN_REF}
            type=registry,ref=${CACHE_IMAGE_NAME}:main"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:${CLEAN_REF}"
            CACHE_TO="${CACHE_TO},mode=max"

          else
            # For all other cases (e.g., tag builds), we read from and write to
            # the main branch cache.
            CACHE_FROM="type=registry,ref=${CACHE_IMAGE_NAME}:main"
            CACHE_TO="type=registry,ref=${CACHE_IMAGE_NAME}:main,mode=max"
          fi

          echo "::group::Cache tags"
          echo "CACHE_IMAGE_NAME=${CACHE_IMAGE_NAME}"
          echo "REF_NAME=${REF_NAME}"
          echo "CLEAN_REF=${CLEAN_REF}"
          echo "PR_BRANCH=${PR_BRANCH}"
          echo "CACHE_FROM=${CACHE_FROM}"
          echo "CACHE_TO=${CACHE_TO}"
          echo "::endgroup::"

          # Use HEREDOC syntax to preserve newline characters in cache-from/to
          # strings.
          {
            echo "cache-from<<EOF"
            echo "${CACHE_FROM}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "cache-to<<EOF"
            echo "${CACHE_TO}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Prepare image metadata
        id: meta
        run: |
          # Determine the Docker container tags.
          TAGS=""

          if [[ $GITHUB_REF == refs/tags/* ]]; then
            # Git tags are used 'as is' as docker image tags.
            VERSION=${GITHUB_REF#refs/tags/}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"

            if [[ $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
               # Apply semantic version (semver) expansion, i.e., latest X.Y.Z
               # also becomes X.Y and X
               V=${VERSION:1}
               MAJOR_MINOR=${V%.*}
               MAJOR=${MAJOR_MINOR%.*}
               TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:v${MAJOR_MINOR}"
               TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:v${MAJOR}"
            fi

          elif [[ $GITHUB_REF == 'refs/heads/main' ]]; then
            # Git main branch commits are tagged with docker's default 'latest'
            # tag.
            VERSION=latest
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"
            TAGS="$TAGS,${{ env.DOCKER_IMAGE_NAME }}:"
            TAGS="${TAGS}baseimage-gui-${{ env.BASEIMAGE_VERSION }}"
            TAGS="${TAGS}-gnucash-${{ env.GNUCASH_VERSION }}"

          elif [[ $GITHUB_REF == refs/heads/* ]]; then
            # Other git branches are tagged with the branch name.
            VERSION=${GITHUB_REF#refs/heads/}
            # Basic sanitization (replace / with -)
            VERSION=${VERSION//\//-}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"

          elif [[ $GITHUB_REF == refs/pull/* ]]; then
            # Pull requests are tagged with pr-<PR#>.
            VERSION=pr-${{ github.event.number }}
            TAGS="${{ env.DOCKER_IMAGE_NAME }}:${VERSION}"
          fi

          if [[ $GITHUB_REF == refs/tags/* ]]; then
             LABEL_VERSION=${VERSION#v}
          else
             LABEL_VERSION=$VERSION
          fi

          echo "::group::Image metadata"
          echo "VERSION=${VERSION}"
          echo "TAGS=${TAGS}"
          echo "LABEL_VERSION=${LABEL_VERSION}"
          echo "::endgroup::"

          echo "label_version=${LABEL_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tags=${TAGS}" >> "$GITHUB_OUTPUT"

      - name: Build and push to local registry
        uses: docker/build-push-action@v5
        with:
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci
          build-args: |
            BASEIMAGE_VERSION=${{ env.BASEIMAGE_VERSION }}
            GNUCASH_VERSION=${{ env.GNUCASH_VERSION }}
            LABEL_VERSION=${{ steps.meta.outputs.label_version }}
          cache-from: ${{ steps.cache.outputs.cache-from }}
          cache-to: ${{ steps.cache.outputs.cache-to }}

      - name: Inspect image manifest
        id: inspect
        run: |
          # Get the metadata of all platform images from the multi-platform
          # manifest of the above build.
          docker buildx imagetools inspect \
            localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci
          echo "raw=$(docker buildx imagetools inspect --raw \
            localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci \
            | tr -d '\n')" >> "$GITHUB_OUTPUT"

      - name: Test image
        run: |
          # Run the test suite on all architectures.
          # Get digest and architecture of each manifest in multi-platform
          # image.
          digests=(${{ join(
            fromJSON(steps.inspect.outputs.raw).manifests.*.digest,
            ' '
          ) }})
          architectures=(${{ join(
            fromJSON(steps.inspect.outputs.raw).manifests.*.platform.
                architecture,
            ' '
          ) }})
          if [[ "${#digests[@]}" -ne "${#architectures[@]}" ]]; then
            echo "::error::Digest and arch array lengths do not match:" \
                 "[${architectures[*]}] [${digests[*]}]"
            exit 1
          fi
          for ((i=0; i<${#digests[@]}; i++)); do
            digest="${digests[i]}"
            arch="${architectures[i]}"
            echo "Digest: ${digest}"
            echo "Architecture: ${arch}"
            # The multi-platform docker image contains a bunch of manifests, but
            # only the ones that have an valid architecture are manifests of
            # platform sub-images we can actually run.
            if [[ "${arch}" == 'unknown' ]]; then
              echo '... skipping metadata image'
              continue
            fi
            # Run the test suite on one architecture.
            export DOCKER_IMAGE=localhost:5000/${{ env.DOCKER_IMAGE_NAME }}
            export DOCKER_IMAGE="${DOCKER_IMAGE}:github-ci@${digest}"
            echo "Running tests on image ${DOCKER_IMAGE}..."
            docker pull "${DOCKER_IMAGE}"
            docker run --rm "${DOCKER_IMAGE}" \
                sh -c 'echo Testing image on $(uname -m)...'
            bats -j "$(nproc)" --trace tests
          done

      - name: Login to Dockerhub
        if: github.event_name != 'pull_request'
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Push to Dockerhub
        if: github.event_name != 'pull_request'
        run: |
          # Split the comma-separated tags and format them as arguments
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.meta.outputs.tags }}"
          TAG_ARGS=""
          for tag in "${TAG_ARRAY[@]}"; do
            TAG_ARGS="$TAG_ARGS -t $tag"
          done

          # Use imagetools create to copy the multi-platform image from the
          # local registry to Docker Hub.
          # This avoids rebuilding the image and ensures the exact image tested
          # is pushed.
          # shellcheck disable=SC2086
          docker buildx imagetools create $TAG_ARGS \
            localhost:5000/${{ env.DOCKER_IMAGE_NAME }}:github-ci

      - name: Update Dockerhub description
        if: >-
          github.event_name != 'pull_request' &&
          github.ref == 'refs/heads/main'
        uses: peter-evans/dockerhub-description@v4
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          repository: ${{ env.DOCKER_IMAGE_NAME }}
          readme-filepath: DOCKERHUB.md

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write # Required for creating the release
    steps:
      - name: Check Tag Format
        id: check
        run: |
          if [[ "${{ github.ref_name }}" =~ ^v([0-9]+\.[0-9]+\.[0-9]+)$ ]]; then
            echo "match=true" >> "$GITHUB_OUTPUT"
            # Store the version without the 'v'
            echo "version=${BASH_REMATCH[1]}" >> "$GITHUB_OUTPUT"
          fi

      - name: Create Release
        if: steps.check.outputs.match == 'true'
        uses: softprops/action-gh-release@v2
        with:
          name: Version ${{ steps.check.outputs.version }}
          draft: true
          generate_release_notes: true
          body: |
            Docker image: [${{ vars.DOCKERHUB_USERNAME }}/gnucash:${{ github.ref_name }}][1]

            [1]: https://hub.docker.com/r/${{ vars.DOCKERHUB_USERNAME }}/gnucash/tags?name=${{ github.ref_name }}
